import os
from fastapi import FastAPI, Request, Response
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

try:
    from worker import celery
except ModuleNotFoundError:
    from .worker import celery
import celery.states as states

app = FastAPI()

SERVER_ROOT = os.path.dirname(__file__)

app.mount(
    "/static", StaticFiles(directory=os.path.join(SERVER_ROOT, "static")), name="static"
)

templates = Jinja2Templates(directory=os.path.join(SERVER_ROOT, "templates"))


# option for routing `@app.X` where `X` is one of
# post: to create data.
# get: to read data.
# put: to update data.
# delete: to delete data.

# while it might be tempting to use BackgroundTasks for oemof simulation, those might take up
# resources and it is better to start them in an independent process. BackgroundTasks are for
# not resource intensive processes(https://fastapi.tiangolo.com/tutorial/background-tasks/)


# `127.0.0.1:8000/docs` endpoint will have autogenerated docs for the written code

# Test Driven Development --> https://fastapi.tiangolo.com/tutorial/testing/


@app.get("/")
def index(request: Request) -> Response:
    return templates.TemplateResponse("index.html", {"request": request})


@app.get("/run_simulation")
def run_simulation(request: Request) -> Response:
    """Send a simulation task to a celery worker"""
    input_json = simulation_output = {
        "name": "dummy_json_input",
        "secondary_dict": {"val1": 2, "val2": [5, 6, 7, 8]},
    }
    task = celery.send_task("tasks.run_simulation", args=[input_json], kwargs={})

    return templates.TemplateResponse(
        "submitted_task.html", {"request": request, "task_id": task.id}
    )


@app.get("/check/{task_id}")
async def check_task(task_id: str) -> JSONResponse:
    res = celery.AsyncResult(task_id)
    if res.state == states.PENDING:
        answer = res.state
    else:
        answer = res.result
    return JSONResponse(content=jsonable_encoder(answer))
